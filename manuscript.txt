発表原稿

1. タイトルを読む．

2.

背景です．

OSデバッグやメモリフォレンジックをする際，物理マシンや仮想マシンのメモリを解析しています．
特に，カーネルパニック時には，XenやQEMUを利用したVMでの解析を行います，
解析における，関連ソフトウェアとして，libvmiなどが挙げられます．

3.

そこで課題としてあげられるのは，カーネルパニックを物理マシンに対する解析方法が提供されていないという点です．
なぜ解析ができないかというと，OSが提供していた，メモリマネージメントユニットやシステムコールが使えない状態になっているためです．
なので，現状はVMでの解析に頼るしかない，という状態になっています．

4.

そこで，遠隔ベアメタルマシンの物理メモリの監視アーキテクチャを確立するというのを目的と設定しました．
外部のマシン，つまり(外部電源，外部プロセッサ，外部OSで動く)，監視対象とは別の物理マシンから監視対象ホストをデバッグするということです．
今学期の研究においては，カーネルパニックじに特定のプロセスの仮想アドレス空間を復元し，仮想メモリを参照することで，パニック時の特定プロセスの変数を参照，値が読み取ることを目的とします．
アーキテクチャの概要は下の図の通りです．

5.

次にアプローチです．

x86-64 Linuxではページウォークというものを行なうことで，プロセス中で仮想アドレスと物理アドレスの変換を行っています．
その起点となるのは，下の図のように，CR3の値で，これを元に，四段階のテーブルのインデックスを辿って物理アドレスにたどり着いています．

本研究では，このロジックを解析し，逆算することで，物理アドレスの解析を進めていきます．

6.

先ほど申した，CR3とは，最上位テーブルであるPML4テーブルの先頭の物理アドレスを保持するレジスタです．
CR3の値はプロセスごとに設定されています．

7.

x86-64 Linuxにおけるページウォークに関して説明します．
変換テーブルは四段階存在しています．

仮想アドレスは64bit Linuxにおいては，48bitまでのアドレスを扱えますが，それぞれのフィールどは，各階層のインデックスとなってます．

8.

具体的に．

仮想アドレスが0x1000(16進)の場合，かく階層のインデックスは，0,0,0,1,となるため，それぞれのエントリを辿り，最終的な物理アドレスを求めています．

9.

以上を考慮し，アプローチとして，本研究では，

テーブルの全エントリを実装したプログラムで保持します．
先ほどのロジックを逆算し，仮想アドレス空間を復元することで，論理アドレスを外から参照する，というアプローチです．

10.

環境は以下の通りです．どちらもx86-64 Linuxで実験を行いました．

11.

本研究におけるシステムの概要です．先ほど申したように，物理マシンは監視対象ホストと，監視するホストの2台です．

12.

まず，PCIe Eth Bridgeを監視対象ホストに物理的に設置します．これはsoraさん実装の，PCI Messageとethernetフレームを変換するFPGAデばイスです．

13.

このボードに実装された手続きを実装から物理的に呼び出すことにより，連続した物理メモリの値を取得していきます．

14.

実装です．

本研究においては，CR3の値を監視対象ホストから通知することにしました．
これはレジスタであるため，現在の値を物理メモリ空間から参照することができないためです．
実装のソースはこちらです．

15.

実装の順番を書きます．

16.

最終的に，Page Tableという最下層のエントリから物理アドレスを求め，そのアドレスにアクセスすることで，値を取得します．
最後に，その取得した値が，テーブルのどのインデックスをウォークしてきたのか，というインデックスの情報を以下の処理に通し，仮想アドレスに復元します

17.

評価です．

本研究では，評価として，カーネルパニック時に，対象プロセすの論理メモリ参照の可否，としました．

状態を正しく取得できているか，これを確かめるために現在の時間を変数とし保持するプロセうすを監視します．
このプロセスが監視対象ホストで動いている状態で，別コンソールからカーネルパニックを発生させます．

18.

このプロセスは，CR3の値を通知してくれるプロセスでもあリマス．
出力例は，以下のようになってます．

19.

カーネルパニックが発生し，監視対象ホストが操作不能になったら，本研究の実装を監視するホストで実行します．
これが出力結果の一部です．
この太字になっているところを見てみると，

20.

ここが仮想アドレスで，ここが物理で，これが変数の値です，
監視するプロセスの出力と比較すると，このようになっています．
仮想アドレスは一致しており，値は，5c4970deとなっていることがわかるかと思います．

21.

結論として，

参照したい変数の値がわかりました．

CR3の値あ通知された状態であれば，論理メモリの参照が可能なことが実証できました．

22.

今後ですが，卒論に向けては，

カーネル空間上にあるtaskstruct構造体をメモリのみから探します．
CR3の値は，task_structに保持されているためです．
これにより，全プロセスの論理メモリ参照が可能になります．

また，PCIeETHBridgeを拡張します．
現在は局所的な値しか得ることができない状態だからです．
